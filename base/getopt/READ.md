　　Linux 下很多程序甚至是那些具有图形用户界面（GUI）的程序，都能接受和处理命令行选项。对于某些程序，这是与用户进行交互的主要手段。具有可靠的复杂命令行参数处理机制，会使得您的应用程序更好、更有用。getopt() 就是一个专门设计用来减轻命令行处理负担的库函数。

## 命令行参数

　　命令行程序设计的首要任务是解析命令行参数，GUI派的程序员很少关心这个。在这里，我们对参数采用一种比较通俗的定义——命令行上除命令名之外的字符串。参数由多项构成，项与项之间用空白符彼此隔开。
　　参数进一步分为**选项**和**操作数**。选项用于修改程序的默认行为或为程序提供信息，比较老的约定是以短划线开头。选项后可以跟随一些参数，称为选项参数。剩下的就是操作数了。

## POSIX 约定

　　下面的 POSIX 标准中关于程序名、参数的约定：

 - 程序名不宜少于2个字符且不多于9个字符；
 - 程序名应只包含小写字母和阿拉伯数字；
 - 选项名应该是单字符或单数字，且以短划线（“-”）为前缀；
 - 多个不需要选项参数的选项，可以合并（比如：foo -a -b -c 可以写成 foo -abc）；
 - 选项与其参数之间用空白符隔开；
 - 选项参数不可选；
 - 若选项参数有多个值，要将其并为一个字符串传进来（比如：foo -t "tcp, udp, icmp"），这种情况下，需要自己解决这些参数的分离问题；
 - 选项应该在操作数出现之前出现；
 - 特殊参数（“--”）表明所有参数都结束了，其后任何参数都认为是操作数；
 - 选项如何排列没有什么关系，但对互相排斥的选项，如果一个选项的操作结果覆盖其他选项的操作结果时，最后一个选项起作用；如果选项重复，则顺序处理；
 - 允许操作数的顺序影响程序行为，但需要作文档明确说明；
 - 读写指定文件的程序应该将单个参数“-”作为有意义的标准输入或输出来对待。


## GNU 长选项

　　GNU 鼓励程序员使用 --help、--verbose 等形式的长选项。这些选项不仅不与 POSIX 约定冲突，而且容易记忆，另外也提供了在所有 GNU 工具之间保持一致性的机会。GNU 长选项有自己的约定：

 - 对于已经遵循 POSIX 约定的 GNU 程序，每个短选项都有一个对应的长选项；
 - 额外针对 GNU 的长选项不需要对应的短选项，仅仅推荐要有；
 - 长选项可以缩写成保持唯一性的最短的字符串；
 - 选项参数与长选项之间可以通过空白字符或通过一个‘=’来分隔；
 - 选项参数是可选的（只对短选项有效）；
 - 长选项允许以一个短横线为前缀；


## 远古时代的命令行处理技术

　　C 程序通过 argc 和 argv 参数访问它的命令行参数，argc 是整型数，表示参数的个数（包括命令名），argv 包含指向这些参数的指针数组，argv[0] 就是程序名。
　　对于大型命令行程序，如果还要手动解析参数实在太痛苦了。所以，在很久以前，Unix 支持小组为了简化命令行参数的解析，开发了 getopt() 函数，同时提供了几个外部变量，使得编写遵守 POSIX 的代码变得更加容易。

## 命令行参数解析函数

　　getopt() 函数声明如下：

```
#include <unistd.h>

int getopt(int argc, char * const argv[], const char *optstring);

extern char *optarg;
extern int optind, opterr, optopt;
```

　　该函数的 argc 和 argv 参数通常直接来自于 main() 的参数。optstring 是选项字母组成的字符串。如果该字符串里的任一字符后面有冒号，那么这个选项就要求有选项参数。
　　当给定 getopt() 命令参数的数量（argc）、指向这些参数的数组（argv）和选项字符串（optstring）后，getopt() 将返回第一个选项，并设置一些全局变量。使用相同的参数再次调用该函数时，它将返回下一个选项，并设置相应的全局变量。如果不再有可识别的选项，将返回-1，此任务就完成了。

　　getopt() 所设置的全局变量包括：

 - char *optarg —— 当前选项参数字符串（如果有）；
 - int optind —— argv 的当前索引值。当 getopt() 在 while 循环中使用时，循环结束后，剩下的字符串视为操作数，在 argv[optind] 至 argv[argc-1] 中可以找到；
 - int opterr —— 这个变量非零时，getopt() 函数为“无效选项”和“缺少参数选项”，并输出其错误信息；
 - int optopt —— 当发现无效选项字符之时，getopt() 函数或返回'?'字符，或返回':'字符，并且 optopt 包含了所发现的无效选项字符。


## GNU 提供的 getopt() 函数的特点

　　与 UNIX 支持小组提供的 getopt() 函数不同，GNU 提供的 getopt() 在碰到不以'-'开始的命令行参数时并不会停止寻找选项，而是扫描整个命令行来寻找选项。在处理命令行参数时，它会重新排列 argv 中的元素，这样当重排结束时，所有选项都被移动到前面并且那些继续检查 argv[optind] 至 argv[argc-1] 中剩余参数的代码仍正常工作，但在任何情况下，碰到特殊参数“--”就结束对选项的扫描。

　　GNU getopt() 的第二个特点是可以在 optstrig 中使用特殊的首字符改变 getopt() 的默认行为：

 - optstring[0] = '+'，这样就与 UNIX 支持小组的 getopt() 很相近了；
 - optstring[0] = '-'，会在 optarg 中得到命令行的每一个参数；
 - 以上两种情况下，':'可以作为第二个字符使用。

　　GNU getopt() 的第三个特点是 optstring 中的选项字符后面接两个冒号，就允许该选项有可选参数。在选项参数不存在的情况下，GNU getopt() 返回选项字符并将 optarg 设置为 NULL。

## GNU 长选项命令行解析

　　20世纪90年代，UNIX 应用程序开始支持长选项，即一对短横线、一个描述性选项名称，还可以包含一个使用等号连接的选项的参数。
　　GNU 提供了 getopt-long() 和 getopt-long-only() 函数支持长选项的命令行解析，其中，后者的长选项字符串是以一个短横线开始的，而非一对短横线。

　　getopt_long() 是同时支持长选项和短选项的 getopt() 版本。声明如下：

```
#include <getopt.h>

int getopt_long(int argc, char * const argv[], const char *optstring, 
		const struct option *longopts, int *longindex);

int getopt_long_only(int argc, char * const argv[], const char *optstring, 
		const struct option *longopts, int *longindex);
```

　　getopt_long() 的前三个参数与上面的 getopt() 相同，第4个参数是指向 option 结构的数组，option 结构被称为“长选项表”。longindex 参数如果没有设置为 NULL，那么它就指向一个变量，这个变量会被赋值为寻找到的长选项在 longopts 中的索引值，这可以用于错误诊断。

　　option 结构在 getopt.h 中的声明如下：

```
struct option {
	// 选项名，不包括短横线，比如“help”
	const char *name; 
	// 描述选项是否有选项参数，0为no_argument，1为required_argument，2为optional_argument
	int has_arg;      
	// 如果为NULL，那么getopt_long()返回该结构val字段中的数值
	// 如果不为NULL，getopt_long()会使得它所指向的变量中填入val字段中的数值，并且返回0
	// 如果flag不是NULL，但未发现长选项，那么它所指向的变量的数值不变
	int *flag;        
	// 这个值是发现了长选项时的返回值，或者flag不是NULL是载入*flag中的值
	// 典型情况下，若flag不是NULL，那么val是个真/假值，比如1或0
	// 如果flag是NULL，那么val通常是字符常量，若长选项与短选项一致，
	// 那么，该字符常量应该与optstring中出现的这个选项的参数相同
	int val;
};
```

　　每个长选项在长选项表中都有一个单独条目，该条目需要填入正确的数值。数组中最后的元素的值应该全是0,。数组不需要排序，getopt_long()会进行线性搜索。但是，根据长名字来排序会使程序员读起来更容易。
